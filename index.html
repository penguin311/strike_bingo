<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>스트라이크 빙고 카운터</title>
  <style>
    :root {
      --bg-color: #f0f4f8;
      --card-bg: #ffffff;
      --text-color: #333333;
      --accent: #0078d4;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 20px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      position: relative;
      overflow: hidden; /* 기본: 떠다니는 이미지 화면 밖은 숨김 */
    }

    h1 {
      text-align: center;
      color: var(--accent);
      margin-bottom: 10px;
      position: relative;
      z-index: 1;
      font-size: 32px;
    }

    .layout {
      max-width: 900px;
      margin: 0 auto;
      position: relative;
      z-index: 1; /* 떠다니는 이미지 위에 보이도록 */
    }

    .card {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }

    .card h2 {
      margin-top: 0;
      font-size: 20px;
      color: var(--accent);
    }

    /* ===== 물리 효과로 돌아다니는 s.png (200px) ===== */
    .floating {
      position: fixed;
      width: 200px;
      height: 200px;
      background: url("s.png") no-repeat center/contain;
      pointer-events: none;
      z-index: 0;
    }

    .info {
      font-size: 14px;
      color: #555;
      line-height: 1.5;
    }

    .controls {
      margin-bottom: 8px;
      display: flex;
      align-items: center;
      flex-wrap: wrap;
      gap: 6px;
    }

    .controls label {
      font-size: 14px;
    }

    button {
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-size: 14px;
      cursor: pointer;
    }

    button:hover {
      background: #005a9c;
    }

    input[type="number"] {
      padding: 4px 6px;
      font-size: 14px;
      width: 60px;
    }

    /* ===== 표 영역: 모바일에서 가로 스크롤 허용 ===== */
    .table-wrap {
      width: 100%;
      overflow-x: auto;
    }

    table {
      border-collapse: collapse;
      margin-top: 10px;
      margin-left: auto;
      margin-right: auto;
      white-space: nowrap;
    }

    th, td {
      border: 1px solid #ccc;
      text-align: center;
      font-size: 14px;
    }

    th {
      background: #e4edf5;
      font-weight: 600;
      height: 40px;
      padding: 4px 6px;
    }

    /* 스트라이크 칸: 기본 40×40 정사각형 */
    .frame-cell {
      cursor: pointer;
      width: 40px;
      height: 40px;
      padding: 0;
      user-select: none;
      font-size: 18px;
      line-height: 40px;  /* 세로 중앙 정렬 */
    }

    .frame-cell:hover {
      background: #f3f6fb;
    }

    td.strike {
      background: #ffe7aa;
      color: #d35400;
      font-weight: 700;
      font-size: 20px;
    }

    td.bingo {
      box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.7) inset;
    }

    .player-label {
      background: #f8f9fb;
      font-weight: 600;
      width: 90px;
      cursor: default;
      height: 40px;
      padding: 4px 6px;
      font-size: 16px;
      white-space: nowrap;
    }

    .results {
      margin-top: 12px;
      padding: 10px;
      border-radius: 6px;
      background: #f5f9ff;
      border: 1px solid #d0e2ff;
      font-size: 15px;
    }

    .results span.num {
      font-weight: 700;
      color: #d35400;
    }

    /* ===== 모바일/가로모드 대응 ===== */
    @media (max-width: 600px) {
      body {
        padding: 10px;
      }

      h1 {
        font-size: 24px;
        margin-bottom: 8px;
      }

      .card {
        padding: 12px;
      }

      .card h2 {
        font-size: 18px;
      }

      .info {
        font-size: 12px;
      }

      .controls label {
        font-size: 12px;
      }

      button {
        font-size: 12px;
        padding: 5px 8px;
      }

      input[type="number"] {
        font-size: 12px;
        width: 50px;
      }

      .frame-cell {
        width: 30px;
        height: 30px;
        line-height: 30px;
        font-size: 16px;
      }

      .player-label {
        height: 30px;
        font-size: 14px;
        padding: 2px 4px;
      }

      th {
        height: 30px;
        font-size: 12px;
        padding: 2px 4px;
      }
    }

    /* 가로모드에서는 세로 스크롤 허용 (내용 안 잘리게) */
    @media (orientation: landscape) {
      body {
        overflow: auto;
      }
    }
  </style>
</head>
<body>
  <h1>스트라이크 빙고 카운터</h1>

  <div class="layout">
    <div class="card">
      <h2>스트라이크 표시 & 빙고 계산</h2>
      <p class="info">
        ▷ 표의 칸을 클릭하면 <b>X</b>(스트라이크)가 켜졌다 꺼집니다.<br>
        ▷ 가로 / 세로 / 대각선으로 스트라이크가 <b>3개 연속</b> 이어지면 1빙고로 계산합니다.<br>
        ▷ 같은 줄에서 연속 스트라이크가 4개 이상이어도, <b>겹치지 않게</b> 3개당 1빙고만 셉니다.<br>
        &nbsp;&nbsp;예) XXXX → 1빙고, XXXXXX → 2빙고<br>
        ▷ 10프레임은 최대 3번까지 투구할 수 있으므로 <b>10-1, 10-2, 10-3</b>으로 나누어 표시합니다.<br>
        ▷ 빙고에 포함된 칸은 <b>빨간 테두리</b>로 표시됩니다.<br>
        ▷ 배경의 s.png는 세로모드에서 20개, 가로모드에서 8개가 물리효과로 돌아다닙니다.
      </p>

      <div class="controls">
        <label>
          선수(줄) 수:
          <input type="number" id="playerCountInput" value="4" min="1" max="10">
        </label>
        <button id="applySizeBtn">선수 수 변경</button>
      </div>

      <div class="table-wrap">
        <table id="strikeTable"></table>
      </div>

      <div class="results">
        가로 빙고: <span class="num" id="hCount">0</span> 개<br>
        세로 빙고: <span class="num" id="vCount">0</span> 개<br>
        대각선(↘) 빙고: <span class="num" id="d1Count">0</span> 개<br>
        대각선(↗) 빙고: <span class="num" id="d2Count">0</span> 개<br>
        <hr>
        전체 빙고 합계: <span class="num" id="totalCount">0</span> 개
      </div>
    </div>
  </div>

  <script>
    /* ===== 물리 효과로 움직이는 s.png (충돌 + 벽 바운스), 세로 20개 / 가로 8개 ===== */

    const PORTRAIT_COUNT = 20;
    const LANDSCAPE_COUNT = 8;
    const SIZE = 200;          // 이미지 크기(px)
    const RADIUS = SIZE / 2;
    const SPEED = 1.5;         // 기본 속도 (보통)
    const MAX_SPEED = 4;       // 최대 속도

    let floaters = [];

    function isLandscape() {
      // orientation 지원 안 해도 resize시 대부분 맞게 동작
      return window.matchMedia("(orientation: landscape)").matches;
    }

    function getDesiredFloaterCount() {
      return isLandscape() ? LANDSCAPE_COUNT : PORTRAIT_COUNT;
    }

    function clampSpeed(f) {
      const speed = Math.hypot(f.vx, f.vy);
      if (speed > MAX_SPEED) {
        const ratio = MAX_SPEED / speed;
        f.vx *= ratio;
        f.vy *= ratio;
      }
    }

    function randomRange(min, max) {
      return Math.random() * (max - min) + min;
    }

    function randomVelocity() {
      const angle = Math.random() * Math.PI * 2;
      return {
        vx: Math.cos(angle) * SPEED,
        vy: Math.sin(angle) * SPEED
      };
    }

    function randomNonOverlappingPosition(existing) {
      const width = window.innerWidth;
      const height = window.innerHeight;
      let x, y;
      let tries = 0;

      while (true) {
        x = randomRange(RADIUS, width - RADIUS);
        y = randomRange(RADIUS, height - RADIUS);

        let overlap = false;
        for (const f of existing) {
          const dx = f.x - x;
          const dy = f.y - y;
          const dist = Math.hypot(dx, dy);
          if (dist < SIZE) {
            overlap = true;
            break;
          }
        }

        if (!overlap || tries > 100) {
          return { x, y };
        }
        tries++;
      }
    }

    function setupFloaters() {
      // 기존 엘리먼트 제거
      document.querySelectorAll('.floating').forEach(el => el.remove());
      floaters = [];

      const count = getDesiredFloaterCount();
      for (let i = 0; i < count; i++) {
        const el = document.createElement('div');
        el.className = 'floating';
        document.body.appendChild(el);

        const pos = randomNonOverlappingPosition(floaters);
        const vel = randomVelocity();

        const floater = {
          el,
          x: pos.x,
          y: pos.y,
          vx: vel.vx,
          vy: vel.vy
        };

        clampSpeed(floater);
        floaters.push(floater);
      }
    }

    function handleWallCollision(f) {
      const width = window.innerWidth;
      const height = window.innerHeight;

      if (f.x - RADIUS <= 0 && f.vx < 0) {
        f.vx *= -1;
        f.x = RADIUS;
      } else if (f.x + RADIUS >= width && f.vx > 0) {
        f.vx *= -1;
        f.x = width - RADIUS;
      }

      if (f.y - RADIUS <= 0 && f.vy < 0) {
        f.vy *= -1;
        f.y = RADIUS;
      } else if (f.y + RADIUS >= height && f.vy > 0) {
        f.vy *= -1;
        f.y = height - RADIUS;
      }
    }

    function handleFloaterCollisions() {
      for (let i = 0; i < floaters.length; i++) {
        for (let j = i + 1; j < floaters.length; j++) {
          const a = floaters[i];
          const b = floaters[j];

          const dx = b.x - a.x;
          const dy = b.y - a.y;
          const dist = Math.hypot(dx, dy);
          const minDist = SIZE;

          if (dist > 0 && dist < minDist) {
            const nx = dx / dist;
            const ny = dy / dist;

            const overlap = (minDist - dist) / 2;
            a.x -= nx * overlap;
            a.y -= ny * overlap;
            b.x += nx * overlap;
            b.y += ny * overlap;

            const dvx = a.vx - b.vx;
            const dvy = a.vy - b.vy;
            const relVel = dvx * nx + dvy * ny;

            if (relVel > 0) continue; // 이미 멀어지는 중이면 패스

            const impulse = -2 * relVel / 2; // 질량 동일 가정

            a.vx += -impulse * nx;
            a.vy += -impulse * ny;
            b.vx += impulse * nx;
            b.vy += impulse * ny;

            clampSpeed(a);
            clampSpeed(b);
          }
        }
      }
    }

    function updateFloaters() {
      for (const f of floaters) {
        f.x += f.vx;
        f.y += f.vy;
        handleWallCollision(f);
        f.el.style.left = (f.x - RADIUS) + 'px';
        f.el.style.top  = (f.y - RADIUS) + 'px';
      }
    }

    function animateFloaters() {
      handleFloaterCollisions();
      updateFloaters();
      requestAnimationFrame(animateFloaters);
    }

    // 초기 생성 + 애니메이션 시작
    setupFloaters();
    animateFloaters();

    // 화면 회전 / 크기 변경 시 floater 개수/위치 다시 세팅
    window.addEventListener('resize', () => {
      setupFloaters();
    });


    /* ===== 스트라이크 빙고 로직 ===== */

    // 1~9프레임 + 10프레임(3투구) = 12칸
    const TOTAL_COLS = 12;  // 0~8: 1~9, 9~11: 10-1,10-2,10-3

    const table = document.getElementById('strikeTable');
    const playerCountInput = document.getElementById('playerCountInput');
    const applySizeBtn = document.getElementById('applySizeBtn');

    let players = 4;
    let frames = TOTAL_COLS;
    let strikeData = [];
    let bingoMap = []; // [r][c]가 true면 해당 칸이 빙고에 포함

    function initStrikeData() {
      strikeData = Array.from({ length: players }, () =>
        Array.from({ length: frames }, () => false)
      );
    }

    function initBingoMap() {
      bingoMap = Array.from({ length: players }, () =>
        Array.from({ length: frames }, () => false)
      );
    }

    function headerLabel(colIndex) {
      if (colIndex <= 8) return (colIndex + 1).toString(); // 1~9
      const n = colIndex - 8; // 1,2,3
      return '10-' + n;
    }

    function buildTable() {
      table.innerHTML = '';

      const theadRow = document.createElement('tr');
      const cornerTh = document.createElement('th');
      cornerTh.textContent = '선수 / 프레임';
      theadRow.appendChild(cornerTh);

      for (let c = 0; c < frames; c++) {
        const th = document.createElement('th');
        th.textContent = headerLabel(c);
        theadRow.appendChild(th);
      }
      table.appendChild(theadRow);

      for (let r = 0; r < players; r++) {
        const tr = document.createElement('tr');

        const nameTd = document.createElement('td');
        nameTd.textContent = `P${r + 1}`;
        nameTd.className = 'player-label';
        tr.appendChild(nameTd);

        for (let c = 0; c < frames; c++) {
          const td = document.createElement('td');
          td.classList.add('frame-cell');
          td.dataset.row = r;
          td.dataset.col = c;
          td.addEventListener('click', onCellClick);
          tr.appendChild(td);
        }

        table.appendChild(tr);
      }

      refreshTableView();
      countAndDisplayBingos();
    }

    function onCellClick(e) {
      const td = e.currentTarget;
      const r = parseInt(td.dataset.row, 10);
      const c = parseInt(td.dataset.col, 10);

      strikeData[r][c] = !strikeData[r][c];
      refreshTableView();
      countAndDisplayBingos();
    }

    function refreshTableView() {
      for (let r = 0; r < players; r++) {
        for (let c = 0; c < frames; c++) {
          const td = table.querySelector(`td[data-row="${r}"][data-col="${c}"]`);
          if (!td) continue;

          td.classList.remove('strike', 'bingo');
          td.textContent = '';

          if (strikeData[r][c]) {
            td.classList.add('strike');
            td.textContent = 'X';
          }
          if (bingoMap[r][c]) {
            td.classList.add('bingo');
          }
        }
      }
    }

    applySizeBtn.addEventListener('click', () => {
      let p = parseInt(playerCountInput.value, 10);
      if (isNaN(p) || p < 1) p = 1;
      if (p > 10) p = 10;
      players = p;
      initStrikeData();
      initBingoMap();
      buildTable();
    });

    // ===== 빙고 계산 =====

    const hCountSpan   = document.getElementById('hCount');
    const vCountSpan   = document.getElementById('vCount');
    const d1CountSpan  = document.getElementById('d1Count');
    const d2CountSpan  = document.getElementById('d2Count');
    const totalCountSpan = document.getElementById('totalCount');

    // 한 라인(cells: {r,c} 배열)에 대해
    // 연속된 X(run)들을 찾고, 길이를 기준으로 floor(len/3)만큼 빙고 카운트
    // mark=true면 그 칸들을 bingoMap에 표시
    function processLine(cells, mark) {
      let count = 0;
      let run = [];

      for (let i = 0; i <= cells.length; i++) {
        const inRange = i < cells.length;
        const cell = inRange ? cells[i] : null;
        const isStrike = inRange ? strikeData[cell.r][cell.c] : false;

        if (isStrike) {
          run.push(cell);
        } else {
          if (run.length > 0) {
            const k = Math.floor(run.length / 3);
            count += k;
            if (mark && k > 0) {
              const upto = k * 3; // 앞에서부터 3개씩 k묶음만 사용
              for (let j = 0; j < upto; j++) {
                const { r, c } = run[j];
                bingoMap[r][c] = true;
              }
            }
            run = [];
          }
        }
      }

      return count;
    }

    function countHorizontal(mark) {
      let count = 0;
      for (let r = 0; r < players; r++) {
        const cells = [];
        for (let c = 0; c < frames; c++) {
          cells.push({ r, c });
        }
        count += processLine(cells, mark);
      }
      return count;
    }

    function countVertical(mark) {
      let count = 0;
      for (let c = 0; c < frames; c++) {
        const cells = [];
        for (let r = 0; r < players; r++) {
          cells.push({ r, c });
        }
        count += processLine(cells, mark);
      }
      return count;
    }

    function countDiagDownRight(mark) {
      let count = 0;

      // 왼쪽 가장자리에서 시작
      for (let startR = 0; startR < players; startR++) {
        const cells = [];
        let r = startR;
        let c = 0;
        while (r < players && c < frames) {
          cells.push({ r, c });
          r++;
          c++;
        }
        if (cells.length >= 3) {
          count += processLine(cells, mark);
        }
      }

      // 위쪽에서 시작 (0열은 이미 했으니 1부터)
      for (let startC = 1; startC < frames; startC++) {
        const cells = [];
        let r = 0;
        let c = startC;
        while (r < players && c < frames) {
          cells.push({ r, c });
          r++;
          c++;
        }
        if (cells.length >= 3) {
          count += processLine(cells, mark);
        }
      }

      return count;
    }

    function countDiagUpRight(mark) {
      let count = 0;

      // 왼쪽 아래에서 시작
      for (let startR = 0; startR < players; startR++) {
        const cells = [];
        let r = startR;
        let c = 0;
        while (r >= 0 && c < frames) {
          cells.push({ r, c });
          r--;
          c++;
        }
        if (cells.length >= 3) {
          count += processLine(cells, mark);
        }
      }

      // 아래쪽에서 시작 (0열은 이미 했으니 1부터)
      for (let startC = 1; startC < frames; startC++) {
        const cells = [];
        let r = players - 1;
        let c = startC;
        while (r >= 0 && c < frames) {
          cells.push({ r, c });
          r--;
          c++;
        }
        if (cells.length >= 3) {
          count += processLine(cells, mark);
        }
      }

      return count;
    }

    function countAndDisplayBingos() {
      initBingoMap();

      const h  = countHorizontal(true);
      const v  = countVertical(true);
      const d1 = countDiagDownRight(true);
      const d2 = countDiagUpRight(true);
      const total = h + v + d1 + d2;

      hCountSpan.textContent  = h;
      vCountSpan.textContent  = v;
      d1CountSpan.textContent = d1;
      d2CountSpan.textContent = d2;
      totalCountSpan.textContent = total;

      refreshTableView();
    }

    // 초기 세팅
    initStrikeData();
    initBingoMap();
    buildTable();
  </script>
</body>
</html>
