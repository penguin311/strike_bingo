<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <title>스트라이크 빙고 카운터</title>
  <style>
    :root {
      --bg-color: #f0f4f8;
      --card-bg: #ffffff;
      --text-color: #333333;
      --accent: #0078d4;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 20px;
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      background: var(--bg-color);
      color: var(--text-color);
      position: relative;
      overflow: hidden; /* 떠다니는 이미지 화면 밖은 숨김 */
    }

    h1 {
      text-align: center;
      color: var(--accent);
      margin-bottom: 10px;
      position: relative;
      z-index: 1;
    }

    .layout {
      max-width: 900px;
      margin: 0 auto;
      position: relative;
      z-index: 1; /* 떠다니는 이미지 위에 보이도록 */
    }

    .card {
      background: var(--card-bg);
      border-radius: 8px;
      padding: 16px;
      box-shadow: 0 2px 8px rgba(0,0,0,0.08);
    }

    .card h2 {
      margin-top: 0;
      font-size: 20px;
      color: var(--accent);
    }

    /* ===== 배경에서 돌아다니는 s.png ===== */
    .floating {
      position: fixed;
      width: 200px;
      height: 200px;
      background: url("s.png") no-repeat center/contain;
      pointer-events: none;
      z-index: 0;
      transition: top 10s linear, left 10s linear; /* 위치 바뀔 때 부드럽게 이동 */
    }

    /* 표: 가로 길이 자동, 가운데 정렬 */
    table {
      border-collapse: collapse;
      margin-top: 10px;
      margin-left: auto;
      margin-right: auto;
    }

    th, td {
      border: 1px solid #ccc;
      text-align: center;
      font-size: 14px;
    }

    th {
      background: #e4edf5;
      font-weight: 600;
      height: 40px;
      padding: 4px 6px;
    }

    /* 스트라이크 칸: 정확히 정사각형 40×40 */
    .frame-cell {
      cursor: pointer;
      width: 40px;
      height: 40px;
      padding: 0;
      user-select: none;
      font-size: 18px;
      line-height: 40px;  /* 세로 중앙 정렬 */
    }

    .frame-cell:hover {
      background: #f3f6fb;
    }

    /* X가 있는 칸 */
    td.strike {
      background: #ffe7aa;
      color: #d35400;
      font-weight: 700;
      font-size: 20px;
    }

    /* 빙고에 포함된 칸 표시 */
    td.bingo {
      box-shadow: 0 0 0 3px rgba(255, 0, 0, 0.7) inset;
    }

    /* 선수 이름 칸 */
    .player-label {
      background: #f8f9fb;
      font-weight: 600;
      width: 90px;
      cursor: default;
      height: 40px;
      padding: 4px 6px;
      font-size: 16px;
    }

    .info {
      font-size: 14px;
      color: #555;
      line-height: 1.5;
    }

    .results {
      margin-top: 12px;
      padding: 10px;
      border-radius: 6px;
      background: #f5f9ff;
      border: 1px solid #d0e2ff;
      font-size: 15px;
    }

    .results span.num {
      font-weight: 700;
      color: #d35400;
    }

    button {
      padding: 6px 10px;
      border-radius: 4px;
      border: none;
      background: var(--accent);
      color: #fff;
      font-size: 14px;
      cursor: pointer;
      margin-left: 6px;
    }

    button:hover {
      background: #005a9c;
    }

    input[type="number"] {
      padding: 4px 6px;
      font-size: 14px;
    }
  </style>
</head>
<body>
  <h1>스트라이크 빙고 카운터</h1>

  <div class="layout">
    <div class="card">
      <h2>스트라이크 표시 & 빙고 계산</h2>
      <p class="info">
        ▷ 표의 칸을 클릭하면 <b>X</b>(스트라이크)가 켜졌다 꺼집니다.<br>
        ▷ 가로 / 세로 / 대각선으로 스트라이크가 <b>3개 연속</b> 이어지면 1빙고로 계산합니다.<br>
        ▷ 같은 줄에서 연속 스트라이크가 4개 이상이어도, <b>겹치지 않게</b> 3개당 1빙고만 셉니다.<br>
        &nbsp;&nbsp;예) XXXX → 1빙고, XXXXXX → 2빙고<br>
        ▷ 10프레임은 최대 3번까지 투구할 수 있으므로 <b>10-1, 10-2, 10-3</b>으로 나누어 표시합니다.<br>
        ▷ 빙고에 포함된 칸은 <b>빨간 테두리</b>로 표시됩니다.<br>
        ▷ 배경의 s.png는 장식용이며, 클릭에 영향을 주지 않습니다.
      </p>

      <div style="margin-bottom:8px;">
        <label>
          선수(줄) 수:
          <input type="number" id="playerCountInput" value="4" min="1" max="10" style="width:60px;">
        </label>
        <button id="applySizeBtn">선수 수 변경</button>
      </div>

      <table id="strikeTable"></table>

      <div class="results">
        가로 빙고: <span class="num" id="hCount">0</span> 개<br>
        세로 빙고: <span class="num" id="vCount">0</span> 개<br>
        대각선(↘) 빙고: <span class="num" id="d1Count">0</span> 개<br>
        대각선(↗) 빙고: <span class="num" id="d2Count">0</span> 개<br>
        <hr>
        전체 빙고 합계: <span class="num" id="totalCount">0</span> 개
      </div>
    </div>
  </div>

  <script>
    /* ===== 배경에서 랜덤하게 움직이는 s.png 20개 ===== */
    const FLOATING_COUNT = 20;

    function randomPosition() {
      const top = Math.random() * 100;
      const left = Math.random() * 100;
      return { top, left };
    }

    function moveToRandomPosition(el) {
      const { top, left } = randomPosition();
      el.style.top = top + 'vh';
      el.style.left = left + 'vw';
    }

    function createFloatingImages() {
      for (let i = 0; i < FLOATING_COUNT; i++) {
        const el = document.createElement('div');
        el.className = 'floating';
        document.body.appendChild(el);

        // 첫 위치
        moveToRandomPosition(el);

        // 일정 시간마다 랜덤 위치로 이동
        const intervalTime = 3000 + Math.random() * 3000; // 3~6초 사이
        setInterval(() => {
          moveToRandomPosition(el);
        }, intervalTime);
      }
    }

    // 페이지 로드 시 생성
    createFloatingImages();


    /* ===== 스트라이크 빙고 로직 ===== */

    // 1~9프레임 + 10프레임(3투구) = 12칸
    const TOTAL_COLS = 12;  // 0~8: 1~9, 9~11: 10-1,10-2,10-3

    const table = document.getElementById('strikeTable');
    const playerCountInput = document.getElementById('playerCountInput');
    const applySizeBtn = document.getElementById('applySizeBtn');

    let players = 4;
    let frames = TOTAL_COLS;
    let strikeData = [];
    let bingoMap = []; // [r][c]가 true면 해당 칸이 빙고에 포함

    function initStrikeData() {
      strikeData = Array.from({ length: players }, () =>
        Array.from({ length: frames }, () => false)
      );
    }

    function initBingoMap() {
      bingoMap = Array.from({ length: players }, () =>
        Array.from({ length: frames }, () => false)
      );
    }

    function headerLabel(colIndex) {
      if (colIndex <= 8) return (colIndex + 1).toString(); // 1~9
      const n = colIndex - 8; // 1,2,3
      return '10-' + n;
    }

    function buildTable() {
      table.innerHTML = '';

      const theadRow = document.createElement('tr');
      const cornerTh = document.createElement('th');
      cornerTh.textContent = '선수 / 프레임';
      theadRow.appendChild(cornerTh);

      for (let c = 0; c < frames; c++) {
        const th = document.createElement('th');
        th.textContent = headerLabel(c);
        theadRow.appendChild(th);
      }
      table.appendChild(theadRow);

      for (let r = 0; r < players; r++) {
        const tr = document.createElement('tr');

        const nameTd = document.createElement('td');
        nameTd.textContent = `P${r + 1}`;
        nameTd.className = 'player-label';
        tr.appendChild(nameTd);

        for (let c = 0; c < frames; c++) {
          const td = document.createElement('td');
          td.classList.add('frame-cell');
          td.dataset.row = r;
          td.dataset.col = c;
          td.addEventListener('click', onCellClick);
          tr.appendChild(td);
        }

        table.appendChild(tr);
      }

      refreshTableView();
      countAndDisplayBingos();
    }

    function onCellClick(e) {
      const td = e.currentTarget;
      const r = parseInt(td.dataset.row, 10);
      const c = parseInt(td.dataset.col, 10);

      strikeData[r][c] = !strikeData[r][c];
      refreshTableView();
      countAndDisplayBingos();
    }

    function refreshTableView() {
      for (let r = 0; r < players; r++) {
        for (let c = 0; c < frames; c++) {
          const td = table.querySelector(`td[data-row="${r}"][data-col="${c}"]`);
          if (!td) continue;

          td.classList.remove('strike', 'bingo');
          td.textContent = '';

          if (strikeData[r][c]) {
            td.classList.add('strike');
            td.textContent = 'X';
          }
          if (bingoMap[r][c]) {
            td.classList.add('bingo');
          }
        }
      }
    }

    applySizeBtn.addEventListener('click', () => {
      let p = parseInt(playerCountInput.value, 10);
      if (isNaN(p) || p < 1) p = 1;
      if (p > 10) p = 10;
      players = p;
      initStrikeData();
      initBingoMap();
      buildTable();
    });

    // ===== 빙고 계산 =====

    const hCountSpan   = document.getElementById('hCount');
    const vCountSpan   = document.getElementById('vCount');
    const d1CountSpan  = document.getElementById('d1Count');
    const d2CountSpan  = document.getElementById('d2Count');
    const totalCountSpan = document.getElementById('totalCount');

    // 한 라인(cells: {r,c} 배열)에 대해
    // 연속된 X(run)들을 찾고, 길이를 기준으로 floor(len/3)만큼 빙고 카운트
    // mark=true면 그 칸들을 bingoMap에 표시
    function processLine(cells, mark) {
      let count = 0;
      let run = [];

      for (let i = 0; i <= cells.length; i++) {
        const inRange = i < cells.length;
        const cell = inRange ? cells[i] : null;
        const isStrike = inRange ? strikeData[cell.r][cell.c] : false;

        if (isStrike) {
          run.push(cell);
        } else {
          if (run.length > 0) {
            const k = Math.floor(run.length / 3);
            count += k;
            if (mark && k > 0) {
              const upto = k * 3; // 앞에서부터 3개씩 k묶음만 사용
              for (let j = 0; j < upto; j++) {
                const { r, c } = run[j];
                bingoMap[r][c] = true;
              }
            }
            run = [];
          }
        }
      }

      return count;
    }

    function countHorizontal(mark) {
      let count = 0;
      for (let r = 0; r < players; r++) {
        const cells = [];
        for (let c = 0; c < frames; c++) {
          cells.push({ r, c });
        }
        count += processLine(cells, mark);
      }
      return count;
    }

    function countVertical(mark) {
      let count = 0;
      for (let c = 0; c < frames; c++) {
        const cells = [];
        for (let r = 0; r < players; r++) {
          cells.push({ r, c });
        }
        count += processLine(cells, mark);
      }
      return count;
    }

    function countDiagDownRight(mark) {
      let count = 0;

      // 왼쪽 가장자리에서 시작
      for (let startR = 0; startR < players; startR++) {
        const cells = [];
        let r = startR;
        let c = 0;
        while (r < players && c < frames) {
          cells.push({ r, c });
          r++;
          c++;
        }
        if (cells.length >= 3) {
          count += processLine(cells, mark);
        }
      }

      // 위쪽에서 시작 (0열은 이미 했으니 1부터)
      for (let startC = 1; startC < frames; startC++) {
        const cells = [];
        let r = 0;
        let c = startC;
        while (r < players && c < frames) {
          cells.push({ r, c });
          r++;
          c++;
        }
        if (cells.length >= 3) {
          count += processLine(cells, mark);
        }
      }

      return count;
    }

    function countDiagUpRight(mark) {
      let count = 0;

      // 왼쪽 아래에서 시작
      for (let startR = 0; startR < players; startR++) {
        const cells = [];
        let r = startR;
        let c = 0;
        while (r >= 0 && c < frames) {
          cells.push({ r, c });
          r--;
          c++;
        }
        if (cells.length >= 3) {
          count += processLine(cells, mark);
        }
      }

      // 아래쪽에서 시작 (0열은 이미 했으니 1부터)
      for (let startC = 1; startC < frames; startC++) {
        const cells = [];
        let r = players - 1;
        let c = startC;
        while (r >= 0 && c < frames) {
          cells.push({ r, c });
          r--;
          c++;
        }
        if (cells.length >= 3) {
          count += processLine(cells, mark);
        }
      }

      return count;
    }

    function countAndDisplayBingos() {
      // 빙고 표시 배열 초기화
      initBingoMap();

      const h  = countHorizontal(true);
      const v  = countVertical(true);
      const d1 = countDiagDownRight(true);
      const d2 = countDiagUpRight(true);
      const total = h + v + d1 + d2;

      hCountSpan.textContent  = h;
      vCountSpan.textContent  = v;
      d1CountSpan.textContent = d1;
      d2CountSpan.textContent = d2;
      totalCountSpan.textContent = total;

      // 빙고 반영해서 화면 업데이트
      refreshTableView();
    }

    // 초기 세팅
    initStrikeData();
    initBingoMap();
    buildTable();
  </script>
</body>
</html>
